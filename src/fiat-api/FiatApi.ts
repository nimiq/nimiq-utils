// This API supports using CoinGecko as data provider, with more to come. The free API is used, in an unauthenticated
// fashion, i.e. without api keys. Rate limits are determined based on the user's IP. Note that CoinGecko does not allow
// fetching historic rates past the last 365 days on the free API.
export enum Provider {
    CoinGecko = 'CoinGecko',
}

// Note that CoinGecko supports many more but these are the ones that are currently of interest to us.
export enum CryptoCurrency {
    NIM = 'nim',
    BTC = 'btc',
    ETH = 'eth',
    USDC = 'usdc',
}

export type FiatCurrency<P extends Provider> = P extends Provider.CoinGecko
    ? FiatCurrencyCoinGecko
    : never;

// Fiat currencies supported by CoinGecko.
// Note that CoinGecko supports more vs_currencies (see https://api.coingecko.com/api/v3/simple/supported_vs_currencies)
// but also includes crypto currencies and ounces of gold amongst others that are not fiat currencies. This list here
// has been generated by reducing the vs_currencies to those that are listed as a circulating currency on
// https://en.wikipedia.org/wiki/List_of_circulating_currencies#List_of_circulating_currencies_by_state_or_territory
// via the following script:
//
// const referenceCurrencySymbols = { ...parsed from Wikipedia as described in CurrencyInfo.ts };
// const FiatCurrencyCoinGecko = { ...as defined below };
// const supportedVsCurrencies = (await fetch('https://api.coingecko.com/api/v3/simple/supported_vs_currencies')
//     .then((response) => response.json()))
//     .map((currency) => currency.toUpperCase());
// for (const currency of supportedVsCurrencies) {
//     if (currency in referenceCurrencySymbols && !(currency in FiatCurrencyCoinGecko)) {
//         console.log(`${currency} is a new supported currency`);
//     }
// }
// for (const currency of Object.keys(FiatCurrencyCoinGecko)) {
//     if (!supportedVsCurrencies.includes(currency)) {
//         console.log(`${currency} is not supported anymore`);
//     }
//     if (!(currency in referenceCurrencySymbols)) {
//         console.log(`${currency} is not a circulating currency anymore`);
//     }
// }
export enum FiatCurrencyCoinGecko {
    AED = 'aed', // Arab Emirates Dirham
    ARS = 'ars', // Argentine Peso
    AUD = 'aud', // Australian Dollar
    BDT = 'bdt', // Bangladeshi Taka
    BHD = 'bhd', // Bahraini Dinar
    BMD = 'bmd', // Bermudan Dollar
    BRL = 'brl', // Brazilian Real
    CAD = 'cad', // Canadian Dollar
    CHF = 'chf', // Swiss Franc
    CLP = 'clp', // Chilean Peso
    CNY = 'cny', // Chinese Yuan
    CZK = 'czk', // Czech Koruna
    DKK = 'dkk', // Danish Krone
    EUR = 'eur', // Euro
    GBP = 'gbp', // British Pound
    GEL = 'gel', // Georgian Lari
    HKD = 'hkd', // Hong Kong Dollar
    HUF = 'huf', // Hungarian Forint
    IDR = 'idr', // Indonesian Rupiah
    ILS = 'ils', // Israeli New Shekel
    INR = 'inr', // Indian Rupee
    JPY = 'jpy', // Japanese Yen
    KRW = 'krw', // South Korean Won
    KWD = 'kwd', // Kuwaiti Dinar
    LKR = 'lkr', // Sri Lankan Rupee
    MMK = 'mmk', // Burmese Kyat
    MXN = 'mxn', // Mexican Peso
    MYR = 'myr', // Malaysian Ringgit
    NGN = 'ngn', // Nigerian Naira
    NOK = 'nok', // Norwegian Krone
    NZD = 'nzd', // New Zealand Dollar
    PHP = 'php', // Philippine Peso
    PKR = 'pkr', // Pakistani Rupee
    PLN = 'pln', // Poland Złoty
    RUB = 'rub', // Russian Ruble
    SAR = 'sar', // Saudi Riyal
    SEK = 'sek', // Swedish Krona
    SGD = 'sgd', // Singapore Dollar
    THB = 'thb', // Thai Baht
    TRY = 'try', // Turkish Lira
    TWD = 'twd', // New Taiwan Dollar
    UAH = 'uah', // Ukrainian Hryvnia
    USD = 'usd', // United States Dollar
    // VEF = 'vef', // Discontinued Venezuelan Bolívar Fuerte which was replaced by VES. Rates are completely off.
    VND = 'vnd', // Vietnamese Đồng
    ZAR = 'zar', // South African Rand
}

// Additionally supported fiat currencies, for which we calculate exchange rates by combining coin/USD and fiat/USD
// rates, if they're not directly supported by the chosen provider. Not all of these are supported for fetching
// historical exchange rates. Those that are, are listed in HISTORY_BRIDGEABLE_FIAT_CURRENCIES and all currencies that
// are supported for fetching historical exchange rates via a specific provider, bridged or not, can be checked for via
// isHistorySupportedFiatCurrency(currency, provider).
// This list has been generated via the following script:
//
// const HISTORY_BRIDGEABLE_FIAT_CURRENCIES = [ ... as defined below ];
// const cplData = await fetch('https://firestore.googleapis.com/v1/projects/checkout-service/databases/(default)/'
//     + 'documents/exchangerates/rates').then((response) => response.json());
// const cplCurrencies = Object.keys(cplData.fields.rates.mapValue.fields)
//     .map((currency) => currency.toUpperCase())
//     .filter((currency) => !HISTORY_BRIDGEABLE_FIAT_CURRENCIES.includes(currency))
//     .sort();
// const formatCurrencies = (currencies) => currencies
//     .map((currency) => `    ${currency.toUpperCase()} = '${currency.toLowerCase()}',\n`)
//     .join('');
// console.log('{\n'
//     + '    // History supported bridgeable fiat currencies:\n'
//     + formatCurrencies(HISTORY_BRIDGEABLE_FIAT_CURRENCIES)
//     + '\n    // CPL API currencies:\n'
//     + formatCurrencies(cplCurrencies)
//     + '}');
export enum BridgeableFiatCurrency {
    // History supported bridgeable fiat currencies:
    CRC = 'crc', // Costa Rican colón

    // CPL API currencies:
    AED = 'aed', // Arab Emirates Dirham
    AFN = 'afn', // Afghan afghani
    ALL = 'all', // Albanian lek
    AMD = 'amd', // Armenian dram
    ANG = 'ang', // Netherlands Antillean guilder
    AOA = 'aoa', // Angolan kwanza
    ARS = 'ars', // Argentine Peso
    AUD = 'aud', // Australian Dollar
    AWG = 'awg', // Aruban florin
    AZN = 'azn', // Azerbaijani manat
    BAM = 'bam', // Bosnia and Herzegovina convertible mark
    BBD = 'bbd', // Barbadian dollar
    BDT = 'bdt', // Bangladeshi Taka
    BGN = 'bgn', // Bulgarian lev
    BHD = 'bhd', // Bahraini Dinar
    BIF = 'bif', // Burundian franc
    BMD = 'bmd', // Bermudan Dollar
    BND = 'bnd', // Brunei dollar
    BOB = 'bob', // Bolivian boliviano
    BRL = 'brl', // Brazilian Real
    BSD = 'bsd', // Bahamian dollar
    // BTC = 'btc', // Bitcoin; not a fiat currency
    BTN = 'btn', // Bhutanese ngultrum
    BWP = 'bwp', // Botswana pula
    BYN = 'byn', // Belarusian ruble
    BZD = 'bzd', // Belize dollar
    CAD = 'cad', // Canadian Dollar
    CDF = 'cdf', // Congolese franc
    CHF = 'chf', // Swiss Franc
    // CLF = 'clf', // Chilean Unidad de Fomento; a trade unit; not a fiat currency
    CLP = 'clp', // Chilean Peso
    // CNH = 'cnh', // A Chinese trade unit; not a fiat currency
    CNY = 'cny', // Chinese Yuan
    COP = 'cop', // Colombian peso
    // CUC = 'cuc', // old Cuban convertible peso; replaced by CUP
    CUP = 'cup', // Cuban peso
    CVE = 'cve', // Cape Verdean escudo
    CZK = 'czk', // Czech Koruna
    DJF = 'djf', // Djiboutian franc
    DKK = 'dkk', // Danish Krone
    DOP = 'dop', // Dominican peso
    DZD = 'dzd', // Algerian dinar
    EGP = 'egp', // Egyptian pound
    ERN = 'ern', // Eritrean nakfa
    EUR = 'eur', // Euro
    ETB = 'etb', // Ethiopian birr
    FJD = 'fjd', // Fijian dollar
    FKP = 'fkp', // Falkland Islands pound
    GBP = 'gbp', // British Pound
    GEL = 'gel', // Georgian Lari
    // GGP = 'ggp', // Guernsey pound; at parity with sterling; not a separate ISO 4217 currency
    GHS = 'ghs', // Ghanaian cedi
    GIP = 'gip', // Gibraltar pound
    GMD = 'gmd', // Gambian dalasi
    GNF = 'gnf', // Guinean franc
    GTQ = 'gtq', // Guatemalan quetzal
    GYD = 'gyd', // Guyanese dollar
    HKD = 'hkd', // Hong Kong Dollar
    HNL = 'hnl', // Honduran lempira
    // HRK = 'hrk', // old Croatian Kuna; non-circulating currency
    HTG = 'htg', // Haitian gourde
    HUF = 'huf', // Hungarian Forint
    IDR = 'idr', // Indonesian Rupiah
    ILS = 'ils', // Israeli New Shekel
    // IMP = 'imp', // Manx pound; at parity with sterling; not a separate ISO 4217 currency
    INR = 'inr', // Indian Rupee
    IQD = 'iqd', // Iraqi dinar
    IRR = 'irr', // Iranian rial
    ISK = 'isk', // Icelandic króna
    // JEP = 'jep', // Jersey pound; at parity with sterling; not a separate ISO 4217 currency
    JMD = 'jmd', // Jamaican dollar
    JOD = 'jod', // Jordanian dinar
    JPY = 'jpy', // Japanese Yen
    KES = 'kes', // Kenyan shilling
    KGS = 'kgs', // Kyrgyz som
    KHR = 'khr', // Cambodian riel
    KMF = 'kmf', // Comorian franc
    KPW = 'kpw', // North Korean won
    KRW = 'krw', // South Korean Won
    KWD = 'kwd', // Kuwaiti Dinar
    KYD = 'kyd', // Cayman Islands dollar
    KZT = 'kzt', // Kazakhstani tenge
    LAK = 'lak', // Lao kip
    LBP = 'lbp', // Lebanese pound
    LKR = 'lkr', // Sri Lankan Rupee
    LRD = 'lrd', // Liberian dollar
    LSL = 'lsl', // Lesotho loti
    LYD = 'lyd', // Libyan dinar
    MAD = 'mad', // Moroccan dirham
    MDL = 'mdl', // Moldovan leu
    MGA = 'mga', // Malagasy ariary
    MKD = 'mkd', // Macedonian denar
    MMK = 'mmk', // Burmese Kyat
    MNT = 'mnt', // Mongolian tögrög
    MOP = 'mop', // Macanese pataca
    MRU = 'mru', // Mauritanian ouguiya
    MUR = 'mur', // Mauritian rupee
    MVR = 'mvr', // Maldivian rufiyaa
    MWK = 'mwk', // Malawian kwacha
    MXN = 'mxn', // Mexican Peso
    MYR = 'myr', // Malaysian Ringgit
    MZN = 'mzn', // Mozambican metical
    NAD = 'nad', // Namibian dollar
    NGN = 'ngn', // Nigerian Naira
    NIO = 'nio', // Nicaraguan córdoba
    NOK = 'nok', // Norwegian Krone
    NPR = 'npr', // Nepalese rupee
    NZD = 'nzd', // New Zealand Dollar
    OMR = 'omr', // Omani rial
    PAB = 'pab', // Panamanian balboa
    PEN = 'pen', // Peruvian sol
    PGK = 'pgk', // Papua New Guinean kina
    PHP = 'php', // Philippine Peso
    PKR = 'pkr', // Pakistani Rupee
    PLN = 'pln', // Poland Złoty
    PYG = 'pyg', // Paraguayan guaraní
    QAR = 'qar', // Qatari riyal
    RON = 'ron', // Romanian leu
    RSD = 'rsd', // Serbian dinar
    RUB = 'rub', // Russian Ruble
    RWF = 'rwf', // Rwandan franc
    SAR = 'sar', // Saudi Riyal
    SBD = 'sbd', // Solomon Islands dollar
    SCR = 'scr', // Seychellois rupee
    SDG = 'sdg', // Sudanese pound
    SEK = 'sek', // Swedish Krona
    SGD = 'sgd', // Singapore Dollar
    SHP = 'shp', // Saint Helena pound
    // SLL = 'sll', // old Sierra Leonean leone; replaced by SLE
    SOS = 'sos', // Somali shilling
    SRD = 'srd', // Surinamese dollar
    SSP = 'ssp', // South Sudanese pound
    // STD = 'std', // old São Tomé and Príncipe dobra; replaced by STN
    STN = 'stn', // São Tomé and Príncipe dobra
    // SVC = 'svc', // old El Salvadorian colón; replaced by USD
    SYP = 'syp', // Syrian pound
    SZL = 'szl', // Swazi lilangeni
    THB = 'thb', // Thai Baht
    TJS = 'tjs', // Tajikistani somoni
    TMT = 'tmt', // Turkmenistani manat
    TND = 'tnd', // Tunisian dinar
    TOP = 'top', // Tongan paʻanga
    TRY = 'try', // Turkish Lira
    TTD = 'ttd', // Trinidad and Tobago dollar
    TWD = 'twd', // New Taiwan Dollar
    TZS = 'tzs', // Tanzanian shilling
    UAH = 'uah', // Ukrainian Hryvnia
    UGX = 'ugx', // Ugandan shilling
    USD = 'usd', // United States Dollar
    UYU = 'uyu', // Uruguayan peso
    UZS = 'uzs', // Uzbekistani sum
    VES = 'ves', // Venezuelan sovereign bolívar
    VND = 'vnd', // Vietnamese Đồng
    VUV = 'vuv', // Vanuatu vatu
    WST = 'wst', // Samoan tālā
    XAF = 'xaf', // Central African CFA franc
    // XAG = 'xag', // Silver; not a fiat currency
    // XAU = 'xau', // Gold; not a fiat currency
    XCD = 'xcd', // Eastern Caribbean dollar
    // XDR = 'xdr', // special drawing right issued by the International Monetary Fund; not a fiat currency
    XOF = 'xof', // West African CFA franc
    // XPD = 'xpd', // Palladium; not a fiat currency
    XPF = 'xpf', // CFP franc
    // XPT = 'xpt', // Platinum; not a fiat currency
    YER = 'yer', // Yemeni rial
    ZAR = 'zar', // South African Rand
    ZMW = 'zmw', // Zambian kwacha
    ZWL = 'zwl', // Zimbabwean dollar
}

// Previously, BridgeableFiatCurrency was designed in a way that it did not overlap with FiatCurrencyCoinGecko, i.e.
// entries that would overlap were omitted from BridgeableFiatCurrency. With the upcoming introduction of an additional
// provider with a different set of supported currencies, we change its definition to include all bridgeable currencies,
// including the ones overlapping with currencies supported by either of the providers. Shall the API be reduced again
// to only support one provider in the future, a check similar to the one below can be enabled again:
// Check that no currency supported directly by CoinGecko is handled as bridged currency.
// If there is no overlap, the Extract should yield type never, which is a valid index for the empty object. However, if
// there is an overlap, the result of Extract will be non-empty, which is an invalid index for {}.
// eslint-disable-next-line @typescript-eslint/no-unused-vars
// type __expectNoCoinGeckoWithBridgedOverlap = {}[Extract<
//     keyof typeof BridgeableFiatCurrency,
//     keyof typeof FiatCurrency
// >];

const HISTORY_BRIDGEABLE_FIAT_CURRENCIES = [BridgeableFiatCurrency.CRC as const];
export type HistoryBridgeableFiatCurrency = (typeof HISTORY_BRIDGEABLE_FIAT_CURRENCIES)[number];

const HISTORY_BRIDGEABLE_CURRENCY_TIMEZONES = {
    [BridgeableFiatCurrency.CRC]: 'America/Costa_Rica',
} as const;
// Also checks no HistoryBridgeableFiatCurrency is missing in HISTORY_BRIDGEABLE_CURRENCY_TIMEZONES
type HistoryBridgeableCurrencyTimezone = (typeof HISTORY_BRIDGEABLE_CURRENCY_TIMEZONES)[HistoryBridgeableFiatCurrency];

// Bridgeable fiat currencies using CryptoPayment.link API as bridge. Notably, these do not support historic rates.
type CplApiBridgeableFiatCurrency = Exclude<BridgeableFiatCurrency, HistoryBridgeableFiatCurrency>;
const CPL_API_BRIDGEABLE_FIAT_CURRENCIES: Array<CplApiBridgeableFiatCurrency> = Object.values(BridgeableFiatCurrency)
    .filter((currency): currency is CplApiBridgeableFiatCurrency => (
        !HISTORY_BRIDGEABLE_FIAT_CURRENCIES.includes(currency as any)
    ));

let API_URL_COINGECKO = 'https://api.coingecko.com/api/v3';

const COIN_IDS_COINGECKO = {
    [CryptoCurrency.NIM]: 'nimiq-2',
    [CryptoCurrency.BTC]: 'bitcoin',
    [CryptoCurrency.ETH]: 'ethereum',
    [CryptoCurrency.USDC]: 'usd-coin',
} as const;

const ONE_MINUTE = 60 * 1000;
const ONE_HOUR = 60 * ONE_MINUTE;
const ONE_DAY = 24 * ONE_HOUR;

/**
 * @param url The URL to the CoinGecko v3 API.
 */
export function setCoinGeckoApiUrl(url = 'https://api.coingecko.com/api/v3') {
    API_URL_COINGECKO = url;
}

type VsCurrency<P extends Provider> = FiatCurrency<P> | BridgeableFiatCurrency | CryptoCurrency;
export async function getExchangeRates<
    C extends CryptoCurrency,
    V extends VsCurrency<P>,
    P extends Provider = Provider.CoinGecko,
>(
    cryptoCurrencies: C[],
    vsCurrencies: V[],
    provider: P = Provider.CoinGecko as P,
): Promise<Record<C, Record<V, number | undefined>>> {
    // Make sure the currencies are lower case to match the enums (for users that might not be using typescript which
    // ensures that only valid currency tickers are passed).
    cryptoCurrencies = cryptoCurrencies.map((currency) => currency.toLowerCase() as C);
    vsCurrencies = vsCurrencies.map((currency) => currency.toLowerCase() as V);
    // vsCurrencies handled by the provider. Potentially extended by USD.
    const providerVsCurrencies: Array<FiatCurrency<P> | CryptoCurrency> = [];
    const bridgedVsCurrencies: Array<Exclude<BridgeableFiatCurrency, FiatCurrency<P>>> = [];
    for (const currency of vsCurrencies) {
        if (isProviderSupportedFiatCurrency(currency, provider)) {
            providerVsCurrencies.push(currency);
        } else if (isBridgedFiatCurrency(currency, provider)) {
            bridgedVsCurrencies.push(currency);
        } else {
            throw new Error(`Currency ${currency} not supported for provider ${provider}.`);
        }
    }

    // Check for bridged currencies and fetch their USD exchange rates
    let bridgedExchangeRatesPromise: Promise<Partial<Record<
        Exclude<BridgeableFiatCurrency, FiatCurrency<P>>,
        number | undefined
    >>> | undefined;
    if (bridgedVsCurrencies.length) {
        bridgedExchangeRatesPromise = _getBridgeableFiatCurrencyExchangeRates(bridgedVsCurrencies);
        // Bridged exchange rates are to USD, therefore we need to get the USD exchange rate.
        if (!providerVsCurrencies.includes('usd' as FiatCurrency<P>)) {
            providerVsCurrencies.push('usd' as FiatCurrency<P>);
        }
    }

    let providerExchangeRatesPromise: Promise<Record<C, Record<V, number | undefined>>>;
    switch (provider) {
        case Provider.CoinGecko: {
            // Note that providerVsCurrencies do not need to be converted to coin ids, even for crypto currencies.
            const coinIds = cryptoCurrencies.map((currency) => COIN_IDS_COINGECKO[currency]);
            providerExchangeRatesPromise = _fetch<Record<string, Record<string, number>>>(
                `${API_URL_COINGECKO}/simple/price`
                + `?ids=${coinIds.join(',')}&vs_currencies=${providerVsCurrencies.join(',')}`,
                // Run sequentially to avoid (re)trying many parallel requests waiting on CoinGecko's low rate limit.
                /* sequentially */ true,
            ).then((prices) => cryptoCurrencies.reduce((result, cryptoCurrency) => ({
                ...result,
                // Map CoinGecko coin ids back to CryptoCurrency enum.
                [cryptoCurrency]: prices[COIN_IDS_COINGECKO[cryptoCurrency]],
            }), {} as Record<C, Record<V, number | undefined>>));
            break;
        }
        default: throw new Error(`Unsupported provider ${provider}`);
    }

    const [
        exchangeRates,
        bridgedExchangeRates,
    ] = await Promise.all([providerExchangeRatesPromise, bridgedExchangeRatesPromise]);

    // Add prices calculated from bridged exchange rates, if any.
    for (const [bridgedCurrency, bridgedExchangeRate] of Object.entries<number|undefined>(bridgedExchangeRates || {})) {
        for (const coinPrices of Object.values<Record<V, number | undefined>>(exchangeRates)) {
            const coinUsdPrice = coinPrices['usd' as V];
            coinPrices[bridgedCurrency as V] = bridgedExchangeRate && coinUsdPrice
                ? bridgedExchangeRate * coinUsdPrice
                : undefined;
        }
    }

    // Strictly speaking, USD would need to be filtered out if it was added, but we skip that for code simplicity.
    return exchangeRates;
}

/**
 * Request historic exchange rates by range. Input and output timestamps are in milliseconds.
 *
 * Additional notes for CoinGecko:
 * The free, public API limits historic exchange rates to the past 365 days. Requesting older data results in 401 -
 * Unauthorized errors. The time resolution of returned data depends on the chosen range. CoinGecko provides minutely
 * for ranges within 1 day from the current time, hourly data for any ranges between 1 day and 90 days (do not need to
 * be within 90 days from current time) and daily for ranges above 90 days. Note that minutely data is ~5-10 minutes
 * apart, hourly data about an hour.
 */
export async function getHistoricExchangeRatesByRange<P extends Provider = Provider.CoinGecko>(
    cryptoCurrency: CryptoCurrency,
    vsCurrency: FiatCurrency<P> | HistoryBridgeableFiatCurrency | CryptoCurrency,
    from: number, // in milliseconds
    to: number, // in milliseconds
    provider: P = Provider.CoinGecko as P,
): Promise<Array<[number, number]>> {
    let bridgedCurrency: Exclude<HistoryBridgeableFiatCurrency, FiatCurrency<P>> | undefined;
    let bridgedHistoricRatesPromise: Promise<{[date: string]: number | undefined}> | undefined;
    if (isBridgedFiatCurrency(vsCurrency, provider)) {
        bridgedCurrency = vsCurrency;
        bridgedHistoricRatesPromise = _getHistoricBridgeableFiatCurrencyExchangeRatesByRange(bridgedCurrency, from, to);
        // Bridged exchange rates are to USD, therefore we need to get the USD exchange rate, too.
        vsCurrency = 'usd' as FiatCurrency<P>;
    }

    // from and to are expected in seconds.
    from = Math.floor(from / 1000);
    to = Math.ceil(to / 1000);

    let providerHistoricRatesPromise: Promise<Array<[number, number]>>;
    switch (provider) {
        case Provider.CoinGecko: {
            const coinId = COIN_IDS_COINGECKO[cryptoCurrency.toLowerCase() as CryptoCurrency];
            // Note that timestamps returned by CoinGecko are already in ms, even though from and to were in seconds.
            providerHistoricRatesPromise = _fetch<{ prices: Array<[number, number]> }>(
                `${API_URL_COINGECKO}/coins/${coinId}/market_chart/range`
                + `?vs_currency=${vsCurrency}&from=${from}&to=${to}`,
                // Run sequentially to avoid (re)trying many parallel requests waiting on CoinGecko's low rate limit.
                /* sequentially */ true,
            ).then(({ prices }) => prices);
            break;
        }
        default: throw new Error(`Unsupported provider ${provider}`);
    }

    const [
        providerHistoricRates,
        bridgedHistoricRates,
    ] = await Promise.all([
        providerHistoricRatesPromise,
        bridgedHistoricRatesPromise,
    ]);

    if (bridgedCurrency && bridgedHistoricRates) {
        // Convert exchange rates to bridged currency and omit entries for which no bridged exchange rate is available.
        return providerHistoricRates.map(([timestamp, coinUsdPrice]) => {
            const date = _getDateString(timestamp, HISTORY_BRIDGEABLE_CURRENCY_TIMEZONES[bridgedCurrency!]);
            const bridgedHistoricRate = bridgedHistoricRates[date];
            return bridgedHistoricRate ? [timestamp, coinUsdPrice * bridgedHistoricRate] : null;
        }).filter((entry): entry is [number, number] => entry !== null);
    }

    return providerHistoricRates;
}

/**
 * Get historic exchange rates at specific timestamps in milliseconds.
 */
export async function getHistoricExchangeRates<P extends Provider = Provider.CoinGecko>(
    cryptoCurrency: CryptoCurrency,
    vsCurrency: FiatCurrency<P> | HistoryBridgeableFiatCurrency | CryptoCurrency,
    timestamps: number[],
    provider: P = Provider.CoinGecko as P,
    disableMinutelyData: P extends Provider.CoinGecko ? boolean : never = false as typeof disableMinutelyData,
): Promise<Map<number, number|undefined>> {
    const result = new Map<number, number|undefined>();
    if (!timestamps.length) return result;
    timestamps.sort((a, b) => a - b);

    let prices: Array<[number, number]>;
    switch (provider) {
        case Provider.CoinGecko: {
            // To get the best possible time resolution, we split the timestamps into a chunk within at most 1 day from
            // now and the rest into additional 90 day chunks, see notes on getHistoricExchangeRatesByRange.
            const now = Date.now();
            const chunks: Array<{ start: number, end: number }> = [];
            let timestampIndex = timestamps.length - 1;

            // Create one day chunk
            if (!disableMinutelyData && now - timestamps[timestamps.length - 1] < ONE_DAY - 15 * ONE_MINUTE) {
                // Has a timestamp within last day (minus safety margin in case our clock is slightly off).
                // As one day is calculated from now and not from the timestamp, we have to account for the difference
                // between now and the timestamp.
                const maxChunkLength = ONE_DAY - 15 * ONE_MINUTE - (now - timestamps[timestamps.length - 1]);
                const { chunk, searchEndIndex } = _findCoinGeckoTimestampChunk(
                    timestamps,
                    timestampIndex,
                    maxChunkLength,
                    // Prices are 5-10 min apart, choose margin such we get earlier&later data point for interpolation.
                    10 * ONE_MINUTE,
                );
                chunks.push(chunk);
                timestampIndex = searchEndIndex;
            }

            // Create additional 90 day chunks
            while (timestampIndex >= 0) {
                const { chunk, searchEndIndex } = _findCoinGeckoTimestampChunk(
                    timestamps,
                    timestampIndex,
                    90 * ONE_DAY,
                    // Prices are ~1h apart, chose margin such we get earlier and later data point for interpolation.
                    1.5 * ONE_HOUR,
                );
                chunks.push(chunk);
                timestampIndex = searchEndIndex;
            }

            const fetchPromises = chunks.map(
                ({ start, end }) => getHistoricExchangeRatesByRange(cryptoCurrency, vsCurrency, start, end, provider),
            );
            prices = (await Promise.all(fetchPromises)).reduce(
                (accumulated, singleResult) => [...singleResult, ...accumulated],
                [] as Array<[number, number]>,
            ).sort((a, b) => a[0] - b[0]); // have to re-sort by timestamp as chunks might be overlapping
            break;
        }
        default: throw new Error(`Unsupported provider ${provider}`);
    }

    if (!prices.length) return result; // Happens if provider doesn't have data for any of the requested timestamps,
    // for example for days before the provider started collecting price info or for days in the future.

    // For every requested timestamp interpolate the price from the timestamps we got from the API
    let timestampIndex = 0;
    let priceIndex = 0;
    while (timestampIndex < timestamps.length) {
        // Search priceIndex at which predecessor price timestamp < our timestamp <= current price timestamp.
        const timestamp = timestamps[timestampIndex];
        while (priceIndex < prices.length && prices[priceIndex][0] < timestamp) {
            ++priceIndex;
        }
        if (priceIndex === 0 || priceIndex === prices.length) {
            // Can't interpolate. This should typically not happen as we try to include additional data points for
            // interpolation via an added time margin in our calls to getHistoricExchangeRatesByRange. However, this can
            // still occur in exceptional cases when the gap between two data points was larger than our margin or the
            // requested timestamp was before the provider even started recording price data or is in the future.
            const priceEntry = prices[Math.min(priceIndex, prices.length - 1)];
            if (Math.abs(timestamp - priceEntry[0]) < 2 * ONE_DAY && timestamp <= Date.now()) {
                // Accept the single price entry's price if it's within a limit of 2 days and we're not making
                // assumptions about the future.
                result.set(timestamp, priceEntry[1]);
            }
        } else {
            // Interpolate between priceIndex-1 and priceIndex
            const predecessorEntry = prices[priceIndex - 1];
            const currentEntry = prices[priceIndex];
            const timeDelta = currentEntry[0] - predecessorEntry[0];
            if (timeDelta < 2 * ONE_DAY) {
                // accept the interpolation if timeDelta is within 2 days (typically should be 1 hour).
                const priceDelta = currentEntry[1] - predecessorEntry[1];
                const interpolatedPrice = predecessorEntry[1]
                    + priceDelta * ((timestamp - predecessorEntry[0]) / timeDelta);
                result.set(timestamp, interpolatedPrice);
            }
        }
        ++timestampIndex; // Continue with next timestamp and check same priceIndex
    }
    return result;
}

function _findCoinGeckoTimestampChunk(
    timestamps: number[],
    searchStartIndex: number,
    maxChunkLength: number,
    timeMargin: number,
) {
    maxChunkLength -= 2 * timeMargin;
    const end = timestamps[searchStartIndex];
    let start = end;
    let i = searchStartIndex - 1;
    while (i >= 0 && end - timestamps[i] < maxChunkLength) {
        start = timestamps[i];
        --i;
    }
    return {
        searchEndIndex: i,
        chunk: {
            start: start - timeMargin,
            end: end + timeMargin,
        },
    };
}

let _fetchLock = Promise.resolve(); // note: shared across _fetch calls, i.e. not specific to an api or bridge
async function _fetch<T>(input: RequestInfo, init?: RequestInit, sequentially?: boolean): Promise<T>;
async function _fetch<T>(input: RequestInfo, sequentially?: boolean): Promise<T>;
async function _fetch<T>(
    input: RequestInfo,
    initOrSequentially?: RequestInit | boolean,
    sequentially: boolean = false,
): Promise<T> {
    const init = typeof initOrSequentially !== 'boolean' ? initOrSequentially : undefined;
    sequentially = typeof initOrSequentially === 'boolean' ? initOrSequentially : sequentially;

    let unlock: (() => void) | undefined;
    if (sequentially) {
        const previousLock = _fetchLock;
        _fetchLock = new Promise<void>((resolve) => { unlock = resolve; });
        await previousLock;
    }

    try {
        let result: T | null = null;
        do {
            let retry = true;
            try {
                // eslint-disable-next-line no-await-in-loop
                const response = await fetch(input, init); // Throws when user is offline, in which case we retry.
                if (response.status === 429) throw new Error('Rate limit hit. Retrying...');
                if (!response.ok) {
                    // On other error codes, do not retry, e.g. on status 401 (Unauthorized) for api calls that require
                    // an API key like CoinGecko requests of historic data older than 365 days.
                    retry = false;
                    throw new Error(`${response.status} - ${response.statusText}`);
                }
                // eslint-disable-next-line no-await-in-loop
                result = await response.json();
            } catch (e) {
                if (!retry) throw e;
                // User might be offline or we ran into the provider's rate limiting. CoinGecko allows 100 requests
                // per minute and tells us in the response headers when our next minute starts, but unfortunately
                // due to cors we can not access this information. Therefore, we blindly retry after waiting some
                // time. Note that CoinGecko resets the quota solely based on their system time, i.e. independent
                // of when we resend our request. Therefore, we do not waste time/part of our quota by waiting a
                // bit longer. Note however, that we do not prioritize between our fetches, therefore they will
                // be resolved in random order.
                // eslint-disable-next-line no-await-in-loop
                await new Promise((resolve) => { setTimeout(resolve, 15000); });
            }
        } while (!result);
        return result;
    } finally {
        unlock?.();
    }
}

export function isProviderSupportedFiatCurrency<P extends Provider>(currency: unknown, provider: P)
: currency is FiatCurrency<P> {
    const providerFiatCurrencies = Object.values({
        [Provider.CoinGecko]: FiatCurrencyCoinGecko,
    }[provider]);
    return providerFiatCurrencies.includes(currency as any);
}

export function isBridgeableFiatCurrency(currency: unknown): currency is BridgeableFiatCurrency {
    return Object.values(BridgeableFiatCurrency).includes(currency as any);
}

export function isBridgedFiatCurrency<P extends Provider>(currency: unknown, provider: P)
: currency is Exclude<BridgeableFiatCurrency, FiatCurrency<P>> {
    return isBridgeableFiatCurrency(currency) && !isProviderSupportedFiatCurrency(currency, provider);
}

export function isHistorySupportedFiatCurrency<P extends Provider>(currency: unknown, provider: P)
: currency is FiatCurrency<P> | HistoryBridgeableFiatCurrency {
    return isProviderSupportedFiatCurrency(currency, provider)
        || HISTORY_BRIDGEABLE_FIAT_CURRENCIES.includes(currency as any);
}

/**
 * Get today's exchange rates to USD. Rates can be undefined if the user's clock is in the future.
 */
async function _getBridgeableFiatCurrencyExchangeRates<B extends BridgeableFiatCurrency>(bridgeableFiatCurrencies: B[])
: Promise<Record<B, number | undefined>> {
    const apiPromises: Array<Promise<Partial<Record<B, number | undefined>>>> = [];

    if (bridgeableFiatCurrencies.includes(BridgeableFiatCurrency.CRC as B)) {
        apiPromises.push(_getHistoricBridgeableFiatCurrencyExchangeRatesByRange(BridgeableFiatCurrency.CRC, Date.now())
            .then((crcExchangeRates): Partial<Record<BridgeableFiatCurrency, number | undefined>> => ({
                // There is only a single entry in crcExchangeRates, if any, which is for the current date.
                [BridgeableFiatCurrency.CRC]: Object.values(crcExchangeRates)[0],
            })));
    }

    const cplApiFiatCurrencies = CPL_API_BRIDGEABLE_FIAT_CURRENCIES
        .filter((c) => bridgeableFiatCurrencies.includes(c as B));
    if (cplApiFiatCurrencies.length) {
        apiPromises.push(_fetch<FirebaseRawResponse>(
            'https://firestore.googleapis.com/v1/projects/checkout-service/databases/(default)/documents/'
                + 'exchangerates/rates',
        ).then((cplExchangeRatesResponse) => {
            const cplExchangeRates = _parseCplExchangeRateResponse(cplExchangeRatesResponse);
            // Reduce to only the requested cplApiFiatCurrencies.
            return cplApiFiatCurrencies.reduce((result, currency) => ({
                ...result,
                [currency]: cplExchangeRates[currency],
            }), {});
        }));
    }

    const apiResults = await Promise.all(apiPromises);
    return apiResults.reduce((exchangeRates, apiResult) => ({
        ...exchangeRates,
        ...apiResult,
    }));
}

/**
 * Get historic exchange rates to USD.
 */
async function _getHistoricBridgeableFiatCurrencyExchangeRatesByRange(
    bridgeableFiatCurrency: HistoryBridgeableFiatCurrency,
    from: number, // in milliseconds, inclusive
    to: number = from, // in milliseconds, inclusive
): Promise<{[date: string]: number | undefined}> {
    if (!HISTORY_BRIDGEABLE_FIAT_CURRENCIES.includes(bridgeableFiatCurrency)) {
        // Currently only supported for CRC. Check for users that don't use typescript.
        throw new Error(`Unsupported bridgeable currency for historic rates: ${bridgeableFiatCurrency}`);
    }
    const timezone = HISTORY_BRIDGEABLE_CURRENCY_TIMEZONES[bridgeableFiatCurrency];
    const fromDate = _getDateString(from, timezone);
    const toDate = to === from ? fromDate : _getDateString(to, timezone);
    // Note: entries for future dates are omitted and thus basically undefined which is reflected in the return type.
    return _fetch<{[date: string]: number}>(`https://usd-crc-historic-rate.deno.dev/api/rates/${fromDate}/${toDate}`);
}

/**
 * Format a timestamp as a YYYY-MM-DD date string in a desired timezone.
 */
function _getDateString(timestamp: number | Date, timezone: HistoryBridgeableCurrencyTimezone): string {
    // Define as record such that ts warns us if an entry is missing
    const timezoneUtcOffsets: Record<HistoryBridgeableCurrencyTimezone, number> = {
        'America/Costa_Rica': -6, // fixed offset all year, as Costa Rica has no daylight saving time.
    };
    const timezoneUtcOffset = timezoneUtcOffsets[timezone];
    if (timezoneUtcOffset === undefined) {
        // Arbitrary timezones could be supported via DateTimeFormat.formatToParts, but manually shifting the date is
        // computationally slightly cheaper.
        throw new Error(`Unsupported timezone ${timezone}`);
    }

    // Shift timestamp such that its UTC date equates the date in timezone.
    const shiftedDate = new Date(timestamp);
    shiftedDate.setHours(shiftedDate.getHours() + timezoneUtcOffset); // supports under-/overflow into prev/next day
    return shiftedDate.toISOString().split('T')[0];
}

type FirebaseRawPrimitive = {
    doubleValue: number,
} | {
    integerValue: string,
} | {
    stringValue: string,
} | {
    booleanValue: boolean,
} | {
    nullValue: null,
};
type FirebaseRawValue = FirebaseRawPrimitive | {
    mapValue: {
        fields: Record<string, FirebaseRawPrimitive>,
    },
} | {
    arrayValue: {
        values: FirebaseRawPrimitive[],
    },
};
type FirebaseRawResponse = {
    name: string,
    fields: Record<string, FirebaseRawValue>,
    createTime: string,
    updateTime: string,
};

type FirebasePrimitive = number | string | boolean | null;
type FirebaseValue = FirebasePrimitive | Record<string, FirebasePrimitive> | FirebasePrimitive[];
type FirebaseResponse = Record<string, FirebaseValue>;

function _parseCplExchangeRateResponse(response: FirebaseRawResponse): Record<string, number> {
    const parsed = _parseRawFirebaseResponse(response);
    if (!('rates' in parsed)) throw new Error('Invalid FirebaseResponse');

    const result: Record<string, number> = {};
    for (const [key, value] of Object.entries(parsed.rates as Record<string, FirebasePrimitive>)) {
        if (typeof value !== 'number') throw new Error('Invalid FirebaseResponse');
        result[key.toLowerCase()] = value;
    }
    return result;
}

function _parseRawFirebaseResponse(response: FirebaseRawResponse): FirebaseResponse {
    const result: FirebaseResponse = {};
    for (const [key, value] of Object.entries(response.fields)) {
        result[key] = _parseRawFirebaseValue(value);
    }
    return result;
}

function _parseRawFirebaseValue(raw: FirebaseRawValue): FirebaseValue {
    if ('mapValue' in raw) {
        const result: Record<string, FirebasePrimitive> = {};
        for (const [key, value] of Object.entries(raw.mapValue.fields)) {
            result[key] = _parseRawFirebasePrimitive(value);
        }
        return result;
    }
    if ('arrayValue' in raw) {
        return raw.arrayValue.values.map((value) => _parseRawFirebasePrimitive(value));
    }
    return _parseRawFirebasePrimitive(raw);
}

function _parseRawFirebasePrimitive(raw: FirebaseRawPrimitive): FirebasePrimitive {
    if ('doubleValue' in raw) {
        return raw.doubleValue;
    }
    if ('integerValue' in raw) {
        return parseInt(raw.integerValue, 10);
    }
    if ('stringValue' in raw) {
        return raw.stringValue;
    }
    if ('booleanValue' in raw) {
        return raw.booleanValue;
    }
    if ('nullValue' in raw) {
        return null;
    }
    throw new Error('Invalid FirebaseRawPrimitive');
}
